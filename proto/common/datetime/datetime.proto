syntax = "proto3";

package geniustechspace.common.datetime.v1;

// =============================================================================
// DATETIME MODULE - v1.0.0
// =============================================================================
//
// DateTime ranges and recurring event patterns for scheduling.
// Supports flexible scheduling scenarios with iCalendar compatibility.
//
// USAGE:
// - Event scheduling
// - Availability windows
// - Recurring appointments
// - Business hours
//
// COMPLIANCE:
// - RFC 5545: iCalendar recurrence rules
//
// =============================================================================

import "google/protobuf/timestamp.proto";
import "buf/validate/validate.proto";
// import "common/datetime/enums.proto";

// Language-specific code generation options
option go_package = "github.com/geniustechspace/api-contracts/gen/go/common/v1";
option java_multiple_files = true;
option java_package = "com.geniustechspace.api.common.v1";


// ============================================================================
// DATETIME OBJECT
// ============================================================================
//
// DateTime represents a specific point in time with optional timezone.
//
// USAGE:
// - Event timestamps
// - Appointment scheduling
// - Logging and auditing
// - Time-based triggers
//
// EXAMPLES:
// - 2024-10-15T14:30:00Z for UTC time
// - 2024-10-15T09:30:00-05:00 for US Central Time

message Datetime {
  // Timestamp represents the point in time.
  // USAGE: UTC timezone recommended
  // FORMAT: RFC 3339 / ISO 8601
  google.protobuf.Timestamp timestamp = 1 [(buf.validate.field).required = true];

  // Year of the date.
  // USAGE: Full year (e.g., 2024)
  // RANGE: 1 to 9999
  int32 year = 2 [(buf.validate.field).int32 = {gte: 1900, lte: 2200}];

  // Month of the year.
  // USAGE: 1 (January) to 12 (December)
  // RANGE: 1 to 12
  int32 month = 3 [(buf.validate.field).int32 = {gte: 1, lte: 12}];

  // Day of the month.
  // USAGE: 1 to 31 depending on month/year
  // RANGE: 1 to 31
  int32 day = 4 [(buf.validate.field).int32 = {gte: 1, lte: 31}];

  // Hour of the day (0-23).
  // RANGE: 0 to 23
  // USAGE: 24-hour format
  int32 hour = 5 [(buf.validate.field).int32 = {gte: 0, lte: 23}];

  // Minute of the hour (0-59).
  // RANGE: 0 to 59
  // USAGE: 60-minute format
  int32 minute = 6 [(buf.validate.field).int32 = {gte: 0, lte: 59}];

  // Second of the minute (0-59).
  // RANGE: 0 to 59
  // USAGE: 60-second format
  int32 second = 7 [(buf.validate.field).int32 = {gte: 0, lte: 59}];

  // Optional sub-second precision (0-999).
  // RANGE: 0 to 999
  // USAGE: Millisecond format
  int32 millisecond = 8 [(buf.validate.field).int32 = {gte: 0, lte: 999}];

  // Optional microsecond precision (0-999999).
  // RANGE: 0 to 999999
  // USAGE: Microsecond format
  int32 microsecond = 9 [(buf.validate.field).int32 = {gte: 0, lte: 999999}];

  // Optional nanosecond precision (0-999999999).
  // RANGE: 0 to 999999999
  // USAGE: Nanosecond format
  int32 nanosecond = 10 [(buf.validate.field).int32 = {gte: 0, lte: 999999999}];

  // Optional timezone identifier (IANA format).
  // USAGE: Specify timezone for time context
  string timezone = 11 [(buf.validate.field).string.pattern = "^[A-Za-z_]+/[A-Za-z_]+$"];

  // Optional timezone offset (in minutes).
  // RANGE: -840 to 840 (represents -14:00 to +14:00)
  // USAGE: Specify timezone offset for time context
  int32 timezone_offset = 12 [(buf.validate.field).int32 = {gte: -840, lte: 840}];

  // Reserved for future extensions
  reserved 13 to 20;

}

// =============================================================================
// DATETIME RANGE
// =============================================================================

// DateTimeRange represents a period between two points in time.
//
// USAGE:
// - Event start/end times
// - Availability windows
// - Booking time slots
// - Report date ranges
//
// VALIDATION:
// - start_at must be before ends_at
// - Both timestamps required
message DatetimeRange {
  // Start of the time range (inclusive).
  // USAGE: Beginning of period
  // FORMAT: UTC timezone recommended
  // VALIDATION: Required, must be before ends_at
  google.protobuf.Timestamp start_at = 1 [(buf.validate.field).required = true];

  // End of the time range (exclusive).
  // USAGE: End of period
  // FORMAT: UTC timezone recommended
  // VALIDATION: Required, must be after start_at
  google.protobuf.Timestamp ends_at = 2 [
    (buf.validate.field).required = true,
    (buf.validate.field).timestamp.gt_now = false
  ];

  // Optional timezone identifier for the range.
  // USAGE: Display in user's local timezone
  // FORMAT: IANA timezone database name
  // EXAMPLE: "America/New_York", "Europe/London", "Asia/Tokyo"
  // REFERENCE: https://www.iana.org/time-zones
  string timezone = 3 [(buf.validate.field).string.pattern = "^[A-Za-z_]+/[A-Za-z_]+$"];

  // Whether this time range is all-day (ignores specific times).
  // USAGE: Calendar events, holidays, date-only periods
  // BEHAVIOR: When true, only date portion matters
  bool is_all_day = 4;

  // Reserved for future extensions (e.g., exclusion dates, flexible boundaries)
  reserved 5 to 99;
}

// =============================================================================
// RECURRENCE RULE
// =============================================================================

// RecurrenceRule defines patterns for recurring events (iCalendar RRULE format).
//
// USAGE:
// - Recurring meetings and appointments
// - Scheduled tasks and jobs
// - Subscription renewals
// - Periodic reports
//
// COMPLIANCE:
// - RFC 5545: iCalendar recurrence rule specification
// - Maps to RFC 5545 RRULE components (ends_at â†’ UNTIL)
//
// EXAMPLES:
// - Daily: frequency="DAILY", interval=1
// - Weekly on Mon/Wed/Fri: frequency="WEEKLY", interval=1, days_of_week=["MO","WE","FR"]
// - Monthly on 15th: frequency="MONTHLY", interval=1, days_of_month=[15]
// - Yearly on Jan 1st: frequency="YEARLY", interval=1, months_of_year=[1], days_of_month=[1]
message RecurrenceRule {
  // Recurrence frequency.
  // USAGE: Base unit for recurrence
  // VALUES: See RecurrenceFrequency enum
  // EXAMPLE: RECURRENCE_FREQUENCY_WEEKLY with interval=2 = every 2 weeks
  // STANDARD: RFC 5545 FREQ component
  RecurrenceFrequency frequency = 1 [(buf.validate.field).required = true];

  // Interval between recurrences.
  // USAGE: Multiply frequency by this value
  // EXAMPLE: frequency="DAILY", interval=3 = every 3 days
  // DEFAULT: 1
  // RANGE: >= 1
  int32 interval = 2 [(buf.validate.field).int32 = {gte: 1}];

  // Optional end date for the recurrence.
  // USAGE: Limit recurrence to specific date
  // FORMAT: UTC timezone
  // ALTERNATIVE: Use count instead
  // NOTE: Consistent with DateTimeRange.ends_at naming; maps to RFC 5545 UNTIL
  google.protobuf.Timestamp ends_at = 3 [(buf.validate.field).timestamp.gt_now = false];

  // Optional maximum number of occurrences.
  // USAGE: Limit total number of recurrences
  // EXAMPLE: count=10 = exactly 10 occurrences
  // ALTERNATIVE: Use ends_at instead
  // VALIDATION: >= 1 if specified
  int32 count = 4 [(buf.validate.field).int32 = {gte: 1}];

  // Days of the week for recurrence.
  // USAGE: Specify which weekdays to recur on
  // VALUES: See DayOfWeek enum
  // EXAMPLE: [DAY_OF_WEEK_MONDAY, DAY_OF_WEEK_WEDNESDAY, DAY_OF_WEEK_FRIDAY]
  // APPLIES TO: WEEKLY, MONTHLY, YEARLY frequencies
  repeated DayOfWeek days_of_week = 5;

  // Days of the month for recurrence.
  // USAGE: Specify which days of month to recur on
  // RANGE: 1-31 or -1 to -31 (negative = from end of month)
  // EXAMPLE: [1, 15] = 1st and 15th of each month
  // EXAMPLE: [-1] = last day of month
  // APPLIES TO: MONTHLY, YEARLY frequencies
  repeated int32 days_of_month = 6 [(buf.validate.field).repeated.items.int32 = {
    gte: -31,
    lte: 31,
    not_in: [0]
  }];

  // Months of the year for recurrence.
  // USAGE: Specify which months to recur in
  // RANGE: 1-12 (1=January, 12=December)
  // EXAMPLE: [1, 7] = January and July
  // APPLIES TO: YEARLY frequency
  repeated int32 months_of_year = 7 [(buf.validate.field).repeated.items.int32 = {
    gte: 1,
    lte: 12
  }];

  // Week numbers for recurrence.
  // USAGE: Specify which weeks of year to recur in
  // RANGE: 1-53 or -1 to -53 (negative = from end of year)
  // EXAMPLE: [1, 52] = first and last weeks of year
  // APPLIES TO: YEARLY frequency
  repeated int32 weeks_of_year = 8 [(buf.validate.field).repeated.items.int32 = {
    gte: -53,
    lte: 53,
    not_in: [0]
  }];

  // Starting day of the week (for week calculations).
  // USAGE: Define what day starts the week
  // VALUES: See DayOfWeek enum
  // DEFAULT: DAY_OF_WEEK_MONDAY (Monday per ISO 8601)
  // STANDARD: RFC 5545 WKST component
  DayOfWeek week_start = 9;

  // Optional timezone for recurrence calculations.
  // USAGE: Calculate occurrences in specific timezone
  // FORMAT: IANA timezone database name
  // EXAMPLE: "America/New_York", "Europe/London"
  string timezone = 10 [(buf.validate.field).string.pattern = "^[A-Za-z_]+/[A-Za-z_]+$"];

  // Reserved for future extensions (e.g., exception dates, advanced patterns)
  reserved 11 to 99;
}
