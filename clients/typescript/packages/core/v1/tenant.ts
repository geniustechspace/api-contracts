// @generated by protobuf-ts 2.9.4 with parameter long_type_string
// @generated from protobuf file "core/v1/tenant.proto" (package "core.v1", syntax proto3)
// tslint:disable
//
// =============================================================================
// Tenant Management - Core Multitenancy Primitives
// =============================================================================
// This file defines the foundational types for enterprise multitenancy support.
//
// Key Concepts:
// - Tenant: Top-level isolation boundary (e.g., entire company/organization)
// - Organization: Sub-division within a tenant (e.g., department, business unit)
// - Workspace: Collaboration space within an organization (e.g., project, team)
//
// Security Model:
// - Every request MUST include tenant context via gRPC metadata or HTTP headers
// - Data is isolated at tenant/organization/workspace boundaries
// - Access control enforced at each level
//
// Headers:
//   x-tenant-id: Required - Primary tenant identifier (UUID or custom format)
//   x-organization-id: Optional - Organization within tenant
//   x-workspace-id: Optional - Workspace within organization
//   x-environment: Optional - Environment (production/staging/development)
//
// Compliance:
// - Supports GDPR, HIPAA, SOC 2, PCI DSS requirements
// - Data residency controls per tenant
// - Audit logging configuration per tenant
// - Configurable data retention policies
// =============================================================================
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../google/protobuf/timestamp";
// =============================================================================
// Tenant Context - Required for ALL Requests
// =============================================================================

/**
 * TenantContext provides the isolation context for every request in the system.
 * This MUST be included in all service requests via gRPC metadata or HTTP headers.
 *
 * Usage:
 * - gRPC: Set in metadata with keys: x-tenant-id, x-organization-id, x-workspace-id
 * - HTTP: Set in headers with same keys
 * - All services MUST validate tenant context before processing requests
 * - Services MUST enforce data isolation based on this context
 *
 * @generated from protobuf message core.v1.TenantContext
 */
export interface TenantContext {
    /**
     * Tenant identifier (REQUIRED for all requests).
     * Format: UUID v4 recommended, or custom tenant ID format.
     * Example: "550e8400-e29b-41d4-a716-446655440000"
     *
     * @generated from protobuf field: string tenant_id = 1;
     */
    tenantId: string;
    /**
     * Organization identifier within the tenant (OPTIONAL).
     * Provides sub-tenant isolation for large enterprises.
     * Example: "eng-dept" or "sales-team"
     *
     * @generated from protobuf field: string organization_id = 2;
     */
    organizationId: string;
    /**
     * Workspace identifier within the organization (OPTIONAL).
     * Provides project/team-level isolation.
     * Example: "project-alpha" or "q4-planning"
     *
     * @generated from protobuf field: string workspace_id = 3;
     */
    workspaceId: string;
    /**
     * Environment designation for the request.
     * Used for routing, feature flags, and compliance rules.
     *
     * @generated from protobuf field: core.v1.Environment environment = 4;
     */
    environment: Environment;
    /**
     * Additional tenant-specific metadata for routing and policy decisions.
     * Can include feature flags, A/B test groups, etc.
     *
     * @generated from protobuf field: map<string, string> metadata = 5;
     */
    metadata: {
        [key: string]: string;
    };
}
// =============================================================================
// Tenant Information
// =============================================================================

/**
 * TenantInfo provides comprehensive configuration and metadata for a tenant.
 * This is returned by tenant management services and used for:
 * - Feature gating based on subscription tier
 * - Enforcing resource limits
 * - Compliance requirements
 * - Audit configuration
 *
 * @generated from protobuf message core.v1.TenantInfo
 */
export interface TenantInfo {
    /**
     * Unique tenant identifier (immutable).
     *
     * @generated from protobuf field: string tenant_id = 1;
     */
    tenantId: string;
    /**
     * Human-readable display name.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Current operational status of the tenant.
     *
     * @generated from protobuf field: core.v1.TenantStatus status = 3;
     */
    status: TenantStatus;
    /**
     * Subscription tier - determines available features and limits.
     *
     * @generated from protobuf field: core.v1.SubscriptionTier tier = 4;
     */
    tier: SubscriptionTier;
    /**
     * Feature flags enabled for this tenant.
     * Used for gradual feature rollout and A/B testing.
     *
     * @generated from protobuf field: repeated string feature_flags = 5;
     */
    featureFlags: string[];
    /**
     * Resource usage limits for this tenant.
     *
     * @generated from protobuf field: core.v1.ResourceLimits limits = 6;
     */
    limits?: ResourceLimits;
    /**
     * Compliance requirements and settings.
     *
     * @generated from protobuf field: core.v1.ComplianceSettings compliance = 7;
     */
    compliance?: ComplianceSettings;
    /**
     * Audit logging configuration.
     *
     * @generated from protobuf field: core.v1.AuditSettings audit = 8;
     */
    audit?: AuditSettings;
    /**
     * Timestamp when tenant was created.
     *
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 20;
     */
    createdAt?: Timestamp;
    /**
     * Timestamp when tenant was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 21;
     */
    updatedAt?: Timestamp;
    /**
     * Timestamp when tenant was deleted (soft delete).
     *
     * @generated from protobuf field: google.protobuf.Timestamp deleted_at = 22;
     */
    deletedAt?: Timestamp;
}
// =============================================================================
// Resource Limits
// =============================================================================

/**
 * ResourceLimits defines hard limits on tenant resource consumption.
 * These limits are enforced at runtime to prevent abuse and ensure fair use.
 *
 * @generated from protobuf message core.v1.ResourceLimits
 */
export interface ResourceLimits {
    /**
     * Maximum number of users in the tenant.
     *
     * @generated from protobuf field: int32 max_users = 1;
     */
    maxUsers: number;
    /**
     * Maximum API calls per minute (rate limiting).
     *
     * @generated from protobuf field: int32 max_api_calls_per_minute = 2;
     */
    maxApiCallsPerMinute: number;
    /**
     * Maximum storage in bytes.
     *
     * @generated from protobuf field: int64 max_storage_bytes = 3;
     */
    maxStorageBytes: string;
    /**
     * Maximum concurrent active sessions.
     *
     * @generated from protobuf field: int32 max_concurrent_sessions = 4;
     */
    maxConcurrentSessions: number;
    /**
     * Maximum number of organizations within the tenant.
     *
     * @generated from protobuf field: int32 max_organizations = 5;
     */
    maxOrganizations: number;
    /**
     * Maximum number of workspaces per organization.
     *
     * @generated from protobuf field: int32 max_workspaces_per_org = 6;
     */
    maxWorkspacesPerOrg: number;
    /**
     * Custom resource limits (extensible for future requirements).
     * Key examples: "max_projects", "max_api_keys", "max_webhooks"
     *
     * @generated from protobuf field: map<string, int64> custom_limits = 10;
     */
    customLimits: {
        [key: string]: string;
    };
}
// =============================================================================
// Compliance Settings
// =============================================================================

/**
 * ComplianceSettings defines regulatory and compliance requirements per tenant.
 * Different tenants may have different compliance requirements based on:
 * - Industry (healthcare, finance, etc.)
 * - Geography (GDPR in EU, etc.)
 * - Customer contracts
 *
 * @generated from protobuf message core.v1.ComplianceSettings
 */
export interface ComplianceSettings {
    /**
     * GDPR (General Data Protection Regulation) compliance enabled.
     * Required for tenants with users in the European Union.
     *
     * @generated from protobuf field: bool gdpr_enabled = 1;
     */
    gdprEnabled: boolean;
    /**
     * HIPAA (Health Insurance Portability and Accountability Act) compliance enabled.
     * Required for healthcare-related tenants in the United States.
     *
     * @generated from protobuf field: bool hipaa_enabled = 2;
     */
    hipaaEnabled: boolean;
    /**
     * SOC 2 compliance enabled.
     * Required for enterprise customers with security audit requirements.
     *
     * @generated from protobuf field: bool soc2_enabled = 3;
     */
    soc2Enabled: boolean;
    /**
     * PCI DSS compliance enabled.
     * Required for tenants handling payment card information.
     *
     * @generated from protobuf field: bool pci_dss_enabled = 4;
     */
    pciDssEnabled: boolean;
    /**
     * Data residency requirements.
     *
     * @generated from protobuf field: core.v1.DataResidency data_residency = 5;
     */
    dataResidency?: DataResidency;
    /**
     * Data retention policy in days.
     * After this period, data may be automatically deleted based on policy.
     *
     * @generated from protobuf field: int32 data_retention_days = 6;
     */
    dataRetentionDays: number;
    /**
     * Require encryption at rest for all tenant data.
     *
     * @generated from protobuf field: bool encryption_at_rest_required = 7;
     */
    encryptionAtRestRequired: boolean;
    /**
     * Require encryption in transit (TLS) for all API calls.
     *
     * @generated from protobuf field: bool encryption_in_transit_required = 8;
     */
    encryptionInTransitRequired: boolean;
}
// =============================================================================
// Data Residency
// =============================================================================

/**
 * DataResidency defines geographic restrictions on data storage.
 * Critical for compliance with regional data protection laws.
 *
 * @generated from protobuf message core.v1.DataResidency
 */
export interface DataResidency {
    /**
     * Allowed regions for data storage (ISO 3166-1 alpha-2 country codes).
     * Example: ["US", "CA", "GB"]
     * Empty list means no restrictions.
     *
     * @generated from protobuf field: repeated string allowed_regions = 1;
     */
    allowedRegions: string[];
    /**
     * Prohibited regions where data must not be stored.
     * Takes precedence over allowed_regions.
     * Example: ["CN", "RU"]
     *
     * @generated from protobuf field: repeated string prohibited_regions = 2;
     */
    prohibitedRegions: string[];
    /**
     * Primary region for data storage (preferred location).
     * Example: "US" or "EU"
     *
     * @generated from protobuf field: string primary_region = 3;
     */
    primaryRegion: string;
}
// =============================================================================
// Audit Settings
// =============================================================================

/**
 * AuditSettings configures audit logging behavior per tenant.
 * Audit logs track security-relevant events for compliance and forensics.
 *
 * @generated from protobuf message core.v1.AuditSettings
 */
export interface AuditSettings {
    /**
     * Enable audit logging for this tenant.
     *
     * @generated from protobuf field: bool enabled = 1;
     */
    enabled: boolean;
    /**
     * Audit log retention period in days.
     * Logs older than this are eligible for archival/deletion.
     *
     * @generated from protobuf field: int32 retention_days = 2;
     */
    retentionDays: number;
    /**
     * Types of events to audit.
     * Fine-grained control over what gets logged.
     *
     * @generated from protobuf field: repeated core.v1.AuditEventType event_types = 3;
     */
    eventTypes: AuditEventType[];
    /**
     * External audit log destination (optional).
     * URL or identifier for SIEM integration.
     * Example: "splunk://logs.example.com" or "s3://audit-bucket/tenant-123"
     *
     * @generated from protobuf field: string external_destination = 4;
     */
    externalDestination: string;
    /**
     * Include PII (Personally Identifiable Information) in audit logs.
     * Should be false unless specifically required for compliance.
     *
     * @generated from protobuf field: bool include_pii = 5;
     */
    includePii: boolean;
}
// =============================================================================
// Environment Types
// =============================================================================

/**
 * Environment designates the operational environment for tenant isolation.
 * Different environments may have different:
 * - Security policies
 * - Data retention rules
 * - Feature availability
 * - Performance SLAs
 *
 * @generated from protobuf enum core.v1.Environment
 */
export enum Environment {
    /**
     * Default/unspecified environment (should not be used in production).
     *
     * @generated from protobuf enum value: ENVIRONMENT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Production environment - highest security and compliance requirements.
     *
     * @generated from protobuf enum value: ENVIRONMENT_PRODUCTION = 1;
     */
    PRODUCTION = 1,
    /**
     * Staging environment - pre-production testing.
     *
     * @generated from protobuf enum value: ENVIRONMENT_STAGING = 2;
     */
    STAGING = 2,
    /**
     * Development environment - for active development work.
     *
     * @generated from protobuf enum value: ENVIRONMENT_DEVELOPMENT = 3;
     */
    DEVELOPMENT = 3,
    /**
     * Test environment - for automated testing.
     *
     * @generated from protobuf enum value: ENVIRONMENT_TEST = 4;
     */
    TEST = 4
}
// =============================================================================
// Tenant Status
// =============================================================================

/**
 * TenantStatus represents the operational state of a tenant.
 * Status transitions are controlled and audited.
 *
 * @generated from protobuf enum core.v1.TenantStatus
 */
export enum TenantStatus {
    /**
     * Default/unspecified status (invalid).
     *
     * @generated from protobuf enum value: TENANT_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Active - tenant is operational and can make requests.
     *
     * @generated from protobuf enum value: TENANT_STATUS_ACTIVE = 1;
     */
    ACTIVE = 1,
    /**
     * Suspended - tenant access is temporarily disabled (billing issue, policy violation).
     *
     * @generated from protobuf enum value: TENANT_STATUS_SUSPENDED = 2;
     */
    SUSPENDED = 2,
    /**
     * Deleted - tenant is marked for deletion (soft delete, recoverable).
     *
     * @generated from protobuf enum value: TENANT_STATUS_DELETED = 3;
     */
    DELETED = 3,
    /**
     * Trial - tenant is in trial period with limited features/duration.
     *
     * @generated from protobuf enum value: TENANT_STATUS_TRIAL = 4;
     */
    TRIAL = 4,
    /**
     * Archived - tenant is permanently archived (hard delete pending).
     *
     * @generated from protobuf enum value: TENANT_STATUS_ARCHIVED = 5;
     */
    ARCHIVED = 5
}
// =============================================================================
// Subscription Tier
// =============================================================================

/**
 * SubscriptionTier determines feature availability and resource limits.
 * Higher tiers unlock more features and higher limits.
 *
 * @generated from protobuf enum core.v1.SubscriptionTier
 */
export enum SubscriptionTier {
    /**
     * Default/unspecified tier (should not be used).
     *
     * @generated from protobuf enum value: SUBSCRIPTION_TIER_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Free tier - basic features, limited resources.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_TIER_FREE = 1;
     */
    FREE = 1,
    /**
     * Basic tier - essential features for small teams.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_TIER_BASIC = 2;
     */
    BASIC = 2,
    /**
     * Professional tier - advanced features for growing teams.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_TIER_PROFESSIONAL = 3;
     */
    PROFESSIONAL = 3,
    /**
     * Enterprise tier - full feature set with premium support.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_TIER_ENTERPRISE = 4;
     */
    ENTERPRISE = 4,
    /**
     * Custom tier - bespoke configuration for large organizations.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_TIER_CUSTOM = 5;
     */
    CUSTOM = 5
}
// =============================================================================
// Audit Event Types
// =============================================================================

/**
 * AuditEventType categorizes security-relevant events for audit logging.
 * Each type can be individually enabled/disabled per tenant.
 *
 * @generated from protobuf enum core.v1.AuditEventType
 */
export enum AuditEventType {
    /**
     * Default/unspecified event type.
     *
     * @generated from protobuf enum value: AUDIT_EVENT_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Authentication events (login, logout, MFA, etc.).
     *
     * @generated from protobuf enum value: AUDIT_EVENT_TYPE_AUTHENTICATION = 1;
     */
    AUTHENTICATION = 1,
    /**
     * Authorization events (permission checks, access denied, etc.).
     *
     * @generated from protobuf enum value: AUDIT_EVENT_TYPE_AUTHORIZATION = 2;
     */
    AUTHORIZATION = 2,
    /**
     * Data access events (read operations on sensitive data).
     *
     * @generated from protobuf enum value: AUDIT_EVENT_TYPE_DATA_ACCESS = 3;
     */
    DATA_ACCESS = 3,
    /**
     * Data modification events (create, update, delete).
     *
     * @generated from protobuf enum value: AUDIT_EVENT_TYPE_DATA_MODIFICATION = 4;
     */
    DATA_MODIFICATION = 4,
    /**
     * Configuration changes (tenant settings, user roles, etc.).
     *
     * @generated from protobuf enum value: AUDIT_EVENT_TYPE_CONFIGURATION_CHANGE = 5;
     */
    CONFIGURATION_CHANGE = 5,
    /**
     * Security events (password changes, key rotation, etc.).
     *
     * @generated from protobuf enum value: AUDIT_EVENT_TYPE_SECURITY_EVENT = 6;
     */
    SECURITY_EVENT = 6,
    /**
     * Compliance events (data export, deletion requests, etc.).
     *
     * @generated from protobuf enum value: AUDIT_EVENT_TYPE_COMPLIANCE_EVENT = 7;
     */
    COMPLIANCE_EVENT = 7,
    /**
     * Administrative actions (user management, tenant configuration).
     *
     * @generated from protobuf enum value: AUDIT_EVENT_TYPE_ADMINISTRATIVE = 8;
     */
    ADMINISTRATIVE = 8
}
// @generated message type with reflection information, may provide speed optimized methods
class TenantContext$Type extends MessageType<TenantContext> {
    constructor() {
        super("core.v1.TenantContext", [
            { no: 1, name: "tenant_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", maxLen: "64", pattern: "^[a-zA-Z0-9_-]+$" } } } },
            { no: 2, name: "organization_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "64" } } } },
            { no: 3, name: "workspace_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "64" } } } },
            { no: 4, name: "environment", kind: "enum", T: () => ["core.v1.Environment", Environment, "ENVIRONMENT_"] },
            { no: 5, name: "metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<TenantContext>): TenantContext {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenantId = "";
        message.organizationId = "";
        message.workspaceId = "";
        message.environment = 0;
        message.metadata = {};
        if (value !== undefined)
            reflectionMergePartial<TenantContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TenantContext): TenantContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id */ 1:
                    message.tenantId = reader.string();
                    break;
                case /* string organization_id */ 2:
                    message.organizationId = reader.string();
                    break;
                case /* string workspace_id */ 3:
                    message.workspaceId = reader.string();
                    break;
                case /* core.v1.Environment environment */ 4:
                    message.environment = reader.int32();
                    break;
                case /* map<string, string> metadata */ 5:
                    this.binaryReadMap5(message.metadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: TenantContext["metadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TenantContext["metadata"] | undefined, val: TenantContext["metadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field core.v1.TenantContext.metadata");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: TenantContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* string organization_id = 2; */
        if (message.organizationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.organizationId);
        /* string workspace_id = 3; */
        if (message.workspaceId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.workspaceId);
        /* core.v1.Environment environment = 4; */
        if (message.environment !== 0)
            writer.tag(4, WireType.Varint).int32(message.environment);
        /* map<string, string> metadata = 5; */
        for (let k of globalThis.Object.keys(message.metadata))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.metadata[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message core.v1.TenantContext
 */
export const TenantContext = new TenantContext$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TenantInfo$Type extends MessageType<TenantInfo> {
    constructor() {
        super("core.v1.TenantInfo", [
            { no: 1, name: "tenant_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", maxLen: "255" } } } },
            { no: 3, name: "status", kind: "enum", T: () => ["core.v1.TenantStatus", TenantStatus, "TENANT_STATUS_"] },
            { no: 4, name: "tier", kind: "enum", T: () => ["core.v1.SubscriptionTier", SubscriptionTier, "SUBSCRIPTION_TIER_"] },
            { no: 5, name: "feature_flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "limits", kind: "message", T: () => ResourceLimits },
            { no: 7, name: "compliance", kind: "message", T: () => ComplianceSettings },
            { no: 8, name: "audit", kind: "message", T: () => AuditSettings },
            { no: 20, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 21, name: "updated_at", kind: "message", T: () => Timestamp },
            { no: 22, name: "deleted_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<TenantInfo>): TenantInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenantId = "";
        message.name = "";
        message.status = 0;
        message.tier = 0;
        message.featureFlags = [];
        if (value !== undefined)
            reflectionMergePartial<TenantInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TenantInfo): TenantInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id */ 1:
                    message.tenantId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* core.v1.TenantStatus status */ 3:
                    message.status = reader.int32();
                    break;
                case /* core.v1.SubscriptionTier tier */ 4:
                    message.tier = reader.int32();
                    break;
                case /* repeated string feature_flags */ 5:
                    message.featureFlags.push(reader.string());
                    break;
                case /* core.v1.ResourceLimits limits */ 6:
                    message.limits = ResourceLimits.internalBinaryRead(reader, reader.uint32(), options, message.limits);
                    break;
                case /* core.v1.ComplianceSettings compliance */ 7:
                    message.compliance = ComplianceSettings.internalBinaryRead(reader, reader.uint32(), options, message.compliance);
                    break;
                case /* core.v1.AuditSettings audit */ 8:
                    message.audit = AuditSettings.internalBinaryRead(reader, reader.uint32(), options, message.audit);
                    break;
                case /* google.protobuf.Timestamp created_at */ 20:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 21:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                case /* google.protobuf.Timestamp deleted_at */ 22:
                    message.deletedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deletedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TenantInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* core.v1.TenantStatus status = 3; */
        if (message.status !== 0)
            writer.tag(3, WireType.Varint).int32(message.status);
        /* core.v1.SubscriptionTier tier = 4; */
        if (message.tier !== 0)
            writer.tag(4, WireType.Varint).int32(message.tier);
        /* repeated string feature_flags = 5; */
        for (let i = 0; i < message.featureFlags.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.featureFlags[i]);
        /* core.v1.ResourceLimits limits = 6; */
        if (message.limits)
            ResourceLimits.internalBinaryWrite(message.limits, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* core.v1.ComplianceSettings compliance = 7; */
        if (message.compliance)
            ComplianceSettings.internalBinaryWrite(message.compliance, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* core.v1.AuditSettings audit = 8; */
        if (message.audit)
            AuditSettings.internalBinaryWrite(message.audit, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 20; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 21; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp deleted_at = 22; */
        if (message.deletedAt)
            Timestamp.internalBinaryWrite(message.deletedAt, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message core.v1.TenantInfo
 */
export const TenantInfo = new TenantInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceLimits$Type extends MessageType<ResourceLimits> {
    constructor() {
        super("core.v1.ResourceLimits", [
            { no: 1, name: "max_users", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gte: 0 } } } },
            { no: 2, name: "max_api_calls_per_minute", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gte: 0 } } } },
            { no: 3, name: "max_storage_bytes", kind: "scalar", T: 3 /*ScalarType.INT64*/, options: { "validate.rules": { int64: { gte: "0" } } } },
            { no: 4, name: "max_concurrent_sessions", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gte: 0 } } } },
            { no: 5, name: "max_organizations", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gte: 0 } } } },
            { no: 6, name: "max_workspaces_per_org", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gte: 0 } } } },
            { no: 10, name: "custom_limits", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/ } }
        ]);
    }
    create(value?: PartialMessage<ResourceLimits>): ResourceLimits {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.maxUsers = 0;
        message.maxApiCallsPerMinute = 0;
        message.maxStorageBytes = "0";
        message.maxConcurrentSessions = 0;
        message.maxOrganizations = 0;
        message.maxWorkspacesPerOrg = 0;
        message.customLimits = {};
        if (value !== undefined)
            reflectionMergePartial<ResourceLimits>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceLimits): ResourceLimits {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 max_users */ 1:
                    message.maxUsers = reader.int32();
                    break;
                case /* int32 max_api_calls_per_minute */ 2:
                    message.maxApiCallsPerMinute = reader.int32();
                    break;
                case /* int64 max_storage_bytes */ 3:
                    message.maxStorageBytes = reader.int64().toString();
                    break;
                case /* int32 max_concurrent_sessions */ 4:
                    message.maxConcurrentSessions = reader.int32();
                    break;
                case /* int32 max_organizations */ 5:
                    message.maxOrganizations = reader.int32();
                    break;
                case /* int32 max_workspaces_per_org */ 6:
                    message.maxWorkspacesPerOrg = reader.int32();
                    break;
                case /* map<string, int64> custom_limits */ 10:
                    this.binaryReadMap10(message.customLimits, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: ResourceLimits["customLimits"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ResourceLimits["customLimits"] | undefined, val: ResourceLimits["customLimits"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toString();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field core.v1.ResourceLimits.custom_limits");
            }
        }
        map[key ?? ""] = val ?? "0";
    }
    internalBinaryWrite(message: ResourceLimits, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 max_users = 1; */
        if (message.maxUsers !== 0)
            writer.tag(1, WireType.Varint).int32(message.maxUsers);
        /* int32 max_api_calls_per_minute = 2; */
        if (message.maxApiCallsPerMinute !== 0)
            writer.tag(2, WireType.Varint).int32(message.maxApiCallsPerMinute);
        /* int64 max_storage_bytes = 3; */
        if (message.maxStorageBytes !== "0")
            writer.tag(3, WireType.Varint).int64(message.maxStorageBytes);
        /* int32 max_concurrent_sessions = 4; */
        if (message.maxConcurrentSessions !== 0)
            writer.tag(4, WireType.Varint).int32(message.maxConcurrentSessions);
        /* int32 max_organizations = 5; */
        if (message.maxOrganizations !== 0)
            writer.tag(5, WireType.Varint).int32(message.maxOrganizations);
        /* int32 max_workspaces_per_org = 6; */
        if (message.maxWorkspacesPerOrg !== 0)
            writer.tag(6, WireType.Varint).int32(message.maxWorkspacesPerOrg);
        /* map<string, int64> custom_limits = 10; */
        for (let k of globalThis.Object.keys(message.customLimits))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.customLimits[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message core.v1.ResourceLimits
 */
export const ResourceLimits = new ResourceLimits$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComplianceSettings$Type extends MessageType<ComplianceSettings> {
    constructor() {
        super("core.v1.ComplianceSettings", [
            { no: 1, name: "gdpr_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "hipaa_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "soc2_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "pci_dss_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "data_residency", kind: "message", T: () => DataResidency },
            { no: 6, name: "data_retention_days", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { lte: 3650, gte: 0 } } } },
            { no: 7, name: "encryption_at_rest_required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "encryption_in_transit_required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ComplianceSettings>): ComplianceSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gdprEnabled = false;
        message.hipaaEnabled = false;
        message.soc2Enabled = false;
        message.pciDssEnabled = false;
        message.dataRetentionDays = 0;
        message.encryptionAtRestRequired = false;
        message.encryptionInTransitRequired = false;
        if (value !== undefined)
            reflectionMergePartial<ComplianceSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ComplianceSettings): ComplianceSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool gdpr_enabled */ 1:
                    message.gdprEnabled = reader.bool();
                    break;
                case /* bool hipaa_enabled */ 2:
                    message.hipaaEnabled = reader.bool();
                    break;
                case /* bool soc2_enabled */ 3:
                    message.soc2Enabled = reader.bool();
                    break;
                case /* bool pci_dss_enabled */ 4:
                    message.pciDssEnabled = reader.bool();
                    break;
                case /* core.v1.DataResidency data_residency */ 5:
                    message.dataResidency = DataResidency.internalBinaryRead(reader, reader.uint32(), options, message.dataResidency);
                    break;
                case /* int32 data_retention_days */ 6:
                    message.dataRetentionDays = reader.int32();
                    break;
                case /* bool encryption_at_rest_required */ 7:
                    message.encryptionAtRestRequired = reader.bool();
                    break;
                case /* bool encryption_in_transit_required */ 8:
                    message.encryptionInTransitRequired = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ComplianceSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool gdpr_enabled = 1; */
        if (message.gdprEnabled !== false)
            writer.tag(1, WireType.Varint).bool(message.gdprEnabled);
        /* bool hipaa_enabled = 2; */
        if (message.hipaaEnabled !== false)
            writer.tag(2, WireType.Varint).bool(message.hipaaEnabled);
        /* bool soc2_enabled = 3; */
        if (message.soc2Enabled !== false)
            writer.tag(3, WireType.Varint).bool(message.soc2Enabled);
        /* bool pci_dss_enabled = 4; */
        if (message.pciDssEnabled !== false)
            writer.tag(4, WireType.Varint).bool(message.pciDssEnabled);
        /* core.v1.DataResidency data_residency = 5; */
        if (message.dataResidency)
            DataResidency.internalBinaryWrite(message.dataResidency, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int32 data_retention_days = 6; */
        if (message.dataRetentionDays !== 0)
            writer.tag(6, WireType.Varint).int32(message.dataRetentionDays);
        /* bool encryption_at_rest_required = 7; */
        if (message.encryptionAtRestRequired !== false)
            writer.tag(7, WireType.Varint).bool(message.encryptionAtRestRequired);
        /* bool encryption_in_transit_required = 8; */
        if (message.encryptionInTransitRequired !== false)
            writer.tag(8, WireType.Varint).bool(message.encryptionInTransitRequired);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message core.v1.ComplianceSettings
 */
export const ComplianceSettings = new ComplianceSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataResidency$Type extends MessageType<DataResidency> {
    constructor() {
        super("core.v1.DataResidency", [
            { no: 1, name: "allowed_regions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "prohibited_regions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "primary_region", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "10" } } } }
        ]);
    }
    create(value?: PartialMessage<DataResidency>): DataResidency {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowedRegions = [];
        message.prohibitedRegions = [];
        message.primaryRegion = "";
        if (value !== undefined)
            reflectionMergePartial<DataResidency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataResidency): DataResidency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string allowed_regions */ 1:
                    message.allowedRegions.push(reader.string());
                    break;
                case /* repeated string prohibited_regions */ 2:
                    message.prohibitedRegions.push(reader.string());
                    break;
                case /* string primary_region */ 3:
                    message.primaryRegion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataResidency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string allowed_regions = 1; */
        for (let i = 0; i < message.allowedRegions.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.allowedRegions[i]);
        /* repeated string prohibited_regions = 2; */
        for (let i = 0; i < message.prohibitedRegions.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.prohibitedRegions[i]);
        /* string primary_region = 3; */
        if (message.primaryRegion !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.primaryRegion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message core.v1.DataResidency
 */
export const DataResidency = new DataResidency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuditSettings$Type extends MessageType<AuditSettings> {
    constructor() {
        super("core.v1.AuditSettings", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "retention_days", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { lte: 3650, gte: 0 } } } },
            { no: 3, name: "event_types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["core.v1.AuditEventType", AuditEventType, "AUDIT_EVENT_TYPE_"] },
            { no: 4, name: "external_destination", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxLen: "512" } } } },
            { no: 5, name: "include_pii", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AuditSettings>): AuditSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.retentionDays = 0;
        message.eventTypes = [];
        message.externalDestination = "";
        message.includePii = false;
        if (value !== undefined)
            reflectionMergePartial<AuditSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuditSettings): AuditSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                case /* int32 retention_days */ 2:
                    message.retentionDays = reader.int32();
                    break;
                case /* repeated core.v1.AuditEventType event_types */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.eventTypes.push(reader.int32());
                    else
                        message.eventTypes.push(reader.int32());
                    break;
                case /* string external_destination */ 4:
                    message.externalDestination = reader.string();
                    break;
                case /* bool include_pii */ 5:
                    message.includePii = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuditSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* int32 retention_days = 2; */
        if (message.retentionDays !== 0)
            writer.tag(2, WireType.Varint).int32(message.retentionDays);
        /* repeated core.v1.AuditEventType event_types = 3; */
        if (message.eventTypes.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.eventTypes.length; i++)
                writer.int32(message.eventTypes[i]);
            writer.join();
        }
        /* string external_destination = 4; */
        if (message.externalDestination !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.externalDestination);
        /* bool include_pii = 5; */
        if (message.includePii !== false)
            writer.tag(5, WireType.Varint).bool(message.includePii);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message core.v1.AuditSettings
 */
export const AuditSettings = new AuditSettings$Type();
