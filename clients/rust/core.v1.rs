// @generated
// This file is @generated by prost-build.
// =============================================================================
// Tenant Context - Required for ALL Requests
// =============================================================================

/// TenantContext provides the isolation context for every request in the system.
/// This MUST be included in all service requests via gRPC metadata or HTTP headers.
///
/// Usage:
/// - gRPC: Set in metadata with keys: x-tenant-id, x-organization-id, x-workspace-id
/// - HTTP: Set in headers with same keys
/// - All services MUST validate tenant context before processing requests
/// - Services MUST enforce data isolation based on this context
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TenantContext {
    /// Tenant identifier (REQUIRED for all requests).
    /// Format: UUID v4 recommended, or custom tenant ID format.
    /// Example: "550e8400-e29b-41d4-a716-446655440000"
    #[prost(string, tag="1")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Organization identifier within the tenant (OPTIONAL).
    /// Provides sub-tenant isolation for large enterprises.
    /// Example: "eng-dept" or "sales-team"
    #[prost(string, tag="2")]
    pub organization_id: ::prost::alloc::string::String,
    /// Workspace identifier within the organization (OPTIONAL).
    /// Provides project/team-level isolation.
    /// Example: "project-alpha" or "q4-planning"
    #[prost(string, tag="3")]
    pub workspace_id: ::prost::alloc::string::String,
    /// Environment designation for the request.
    /// Used for routing, feature flags, and compliance rules.
    #[prost(enumeration="Environment", tag="4")]
    pub environment: i32,
    /// Additional tenant-specific metadata for routing and policy decisions.
    /// Can include feature flags, A/B test groups, etc.
    #[prost(map="string, string", tag="5")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
// =============================================================================
// Tenant Information
// =============================================================================

/// TenantInfo provides comprehensive configuration and metadata for a tenant.
/// This is returned by tenant management services and used for:
/// - Feature gating based on subscription tier
/// - Enforcing resource limits
/// - Compliance requirements
/// - Audit configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TenantInfo {
    /// Unique tenant identifier (immutable).
    #[prost(string, tag="1")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Human-readable display name.
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Current operational status of the tenant.
    #[prost(enumeration="TenantStatus", tag="3")]
    pub status: i32,
    /// Subscription tier - determines available features and limits.
    #[prost(enumeration="SubscriptionTier", tag="4")]
    pub tier: i32,
    /// Feature flags enabled for this tenant.
    /// Used for gradual feature rollout and A/B testing.
    #[prost(string, repeated, tag="5")]
    pub feature_flags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Resource usage limits for this tenant.
    #[prost(message, optional, tag="6")]
    pub limits: ::core::option::Option<ResourceLimits>,
    /// Compliance requirements and settings.
    #[prost(message, optional, tag="7")]
    pub compliance: ::core::option::Option<ComplianceSettings>,
    /// Audit logging configuration.
    #[prost(message, optional, tag="8")]
    pub audit: ::core::option::Option<AuditSettings>,
    /// Timestamp when tenant was created.
    #[prost(message, optional, tag="20")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Timestamp when tenant was last updated.
    #[prost(message, optional, tag="21")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Timestamp when tenant was deleted (soft delete).
    #[prost(message, optional, tag="22")]
    pub deleted_at: ::core::option::Option<::prost_types::Timestamp>,
}
// =============================================================================
// Resource Limits
// =============================================================================

/// ResourceLimits defines hard limits on tenant resource consumption.
/// These limits are enforced at runtime to prevent abuse and ensure fair use.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceLimits {
    /// Maximum number of users in the tenant.
    #[prost(int32, tag="1")]
    pub max_users: i32,
    /// Maximum API calls per minute (rate limiting).
    #[prost(int32, tag="2")]
    pub max_api_calls_per_minute: i32,
    /// Maximum storage in bytes.
    #[prost(int64, tag="3")]
    pub max_storage_bytes: i64,
    /// Maximum concurrent active sessions.
    #[prost(int32, tag="4")]
    pub max_concurrent_sessions: i32,
    /// Maximum number of organizations within the tenant.
    #[prost(int32, tag="5")]
    pub max_organizations: i32,
    /// Maximum number of workspaces per organization.
    #[prost(int32, tag="6")]
    pub max_workspaces_per_org: i32,
    /// Custom resource limits (extensible for future requirements).
    /// Key examples: "max_projects", "max_api_keys", "max_webhooks"
    #[prost(map="string, int64", tag="10")]
    pub custom_limits: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
}
// =============================================================================
// Compliance Settings
// =============================================================================

/// ComplianceSettings defines regulatory and compliance requirements per tenant.
/// Different tenants may have different compliance requirements based on:
/// - Industry (healthcare, finance, etc.)
/// - Geography (GDPR in EU, etc.)
/// - Customer contracts
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComplianceSettings {
    /// GDPR (General Data Protection Regulation) compliance enabled.
    /// Required for tenants with users in the European Union.
    #[prost(bool, tag="1")]
    pub gdpr_enabled: bool,
    /// HIPAA (Health Insurance Portability and Accountability Act) compliance enabled.
    /// Required for healthcare-related tenants in the United States.
    #[prost(bool, tag="2")]
    pub hipaa_enabled: bool,
    /// SOC 2 compliance enabled.
    /// Required for enterprise customers with security audit requirements.
    #[prost(bool, tag="3")]
    pub soc2_enabled: bool,
    /// PCI DSS compliance enabled.
    /// Required for tenants handling payment card information.
    #[prost(bool, tag="4")]
    pub pci_dss_enabled: bool,
    /// Data residency requirements.
    #[prost(message, optional, tag="5")]
    pub data_residency: ::core::option::Option<DataResidency>,
    /// Data retention policy in days.
    /// After this period, data may be automatically deleted based on policy.
    #[prost(int32, tag="6")]
    pub data_retention_days: i32,
    /// Require encryption at rest for all tenant data.
    #[prost(bool, tag="7")]
    pub encryption_at_rest_required: bool,
    /// Require encryption in transit (TLS) for all API calls.
    #[prost(bool, tag="8")]
    pub encryption_in_transit_required: bool,
}
// =============================================================================
// Data Residency
// =============================================================================

/// DataResidency defines geographic restrictions on data storage.
/// Critical for compliance with regional data protection laws.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataResidency {
    /// Allowed regions for data storage (ISO 3166-1 alpha-2 country codes).
    /// Example: \["US", "CA", "GB"\]
    /// Empty list means no restrictions.
    #[prost(string, repeated, tag="1")]
    pub allowed_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Prohibited regions where data must not be stored.
    /// Takes precedence over allowed_regions.
    /// Example: \["CN", "RU"\]
    #[prost(string, repeated, tag="2")]
    pub prohibited_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Primary region for data storage (preferred location).
    /// Example: "US" or "EU"
    #[prost(string, tag="3")]
    pub primary_region: ::prost::alloc::string::String,
}
// =============================================================================
// Audit Settings
// =============================================================================

/// AuditSettings configures audit logging behavior per tenant.
/// Audit logs track security-relevant events for compliance and forensics.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuditSettings {
    /// Enable audit logging for this tenant.
    #[prost(bool, tag="1")]
    pub enabled: bool,
    /// Audit log retention period in days.
    /// Logs older than this are eligible for archival/deletion.
    #[prost(int32, tag="2")]
    pub retention_days: i32,
    /// Types of events to audit.
    /// Fine-grained control over what gets logged.
    #[prost(enumeration="AuditEventType", repeated, tag="3")]
    pub event_types: ::prost::alloc::vec::Vec<i32>,
    /// External audit log destination (optional).
    /// URL or identifier for SIEM integration.
    /// Example: "splunk://logs.example.com" or "s3://audit-bucket/tenant-123"
    #[prost(string, tag="4")]
    pub external_destination: ::prost::alloc::string::String,
    /// Include PII (Personally Identifiable Information) in audit logs.
    /// Should be false unless specifically required for compliance.
    #[prost(bool, tag="5")]
    pub include_pii: bool,
}
// =============================================================================
// Environment Types
// =============================================================================

/// Environment designates the operational environment for tenant isolation.
/// Different environments may have different:
/// - Security policies
/// - Data retention rules
/// - Feature availability
/// - Performance SLAs
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Environment {
    /// Default/unspecified environment (should not be used in production).
    Unspecified = 0,
    /// Production environment - highest security and compliance requirements.
    Production = 1,
    /// Staging environment - pre-production testing.
    Staging = 2,
    /// Development environment - for active development work.
    Development = 3,
    /// Test environment - for automated testing.
    Test = 4,
}
impl Environment {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Environment::Unspecified => "ENVIRONMENT_UNSPECIFIED",
            Environment::Production => "ENVIRONMENT_PRODUCTION",
            Environment::Staging => "ENVIRONMENT_STAGING",
            Environment::Development => "ENVIRONMENT_DEVELOPMENT",
            Environment::Test => "ENVIRONMENT_TEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENVIRONMENT_UNSPECIFIED" => Some(Self::Unspecified),
            "ENVIRONMENT_PRODUCTION" => Some(Self::Production),
            "ENVIRONMENT_STAGING" => Some(Self::Staging),
            "ENVIRONMENT_DEVELOPMENT" => Some(Self::Development),
            "ENVIRONMENT_TEST" => Some(Self::Test),
            _ => None,
        }
    }
}
// =============================================================================
// Tenant Status
// =============================================================================

/// TenantStatus represents the operational state of a tenant.
/// Status transitions are controlled and audited.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TenantStatus {
    /// Default/unspecified status (invalid).
    Unspecified = 0,
    /// Active - tenant is operational and can make requests.
    Active = 1,
    /// Suspended - tenant access is temporarily disabled (billing issue, policy violation).
    Suspended = 2,
    /// Deleted - tenant is marked for deletion (soft delete, recoverable).
    Deleted = 3,
    /// Trial - tenant is in trial period with limited features/duration.
    Trial = 4,
    /// Archived - tenant is permanently archived (hard delete pending).
    Archived = 5,
}
impl TenantStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TenantStatus::Unspecified => "TENANT_STATUS_UNSPECIFIED",
            TenantStatus::Active => "TENANT_STATUS_ACTIVE",
            TenantStatus::Suspended => "TENANT_STATUS_SUSPENDED",
            TenantStatus::Deleted => "TENANT_STATUS_DELETED",
            TenantStatus::Trial => "TENANT_STATUS_TRIAL",
            TenantStatus::Archived => "TENANT_STATUS_ARCHIVED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TENANT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "TENANT_STATUS_ACTIVE" => Some(Self::Active),
            "TENANT_STATUS_SUSPENDED" => Some(Self::Suspended),
            "TENANT_STATUS_DELETED" => Some(Self::Deleted),
            "TENANT_STATUS_TRIAL" => Some(Self::Trial),
            "TENANT_STATUS_ARCHIVED" => Some(Self::Archived),
            _ => None,
        }
    }
}
// =============================================================================
// Subscription Tier
// =============================================================================

/// SubscriptionTier determines feature availability and resource limits.
/// Higher tiers unlock more features and higher limits.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubscriptionTier {
    /// Default/unspecified tier (should not be used).
    Unspecified = 0,
    /// Free tier - basic features, limited resources.
    Free = 1,
    /// Basic tier - essential features for small teams.
    Basic = 2,
    /// Professional tier - advanced features for growing teams.
    Professional = 3,
    /// Enterprise tier - full feature set with premium support.
    Enterprise = 4,
    /// Custom tier - bespoke configuration for large organizations.
    Custom = 5,
}
impl SubscriptionTier {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SubscriptionTier::Unspecified => "SUBSCRIPTION_TIER_UNSPECIFIED",
            SubscriptionTier::Free => "SUBSCRIPTION_TIER_FREE",
            SubscriptionTier::Basic => "SUBSCRIPTION_TIER_BASIC",
            SubscriptionTier::Professional => "SUBSCRIPTION_TIER_PROFESSIONAL",
            SubscriptionTier::Enterprise => "SUBSCRIPTION_TIER_ENTERPRISE",
            SubscriptionTier::Custom => "SUBSCRIPTION_TIER_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUBSCRIPTION_TIER_UNSPECIFIED" => Some(Self::Unspecified),
            "SUBSCRIPTION_TIER_FREE" => Some(Self::Free),
            "SUBSCRIPTION_TIER_BASIC" => Some(Self::Basic),
            "SUBSCRIPTION_TIER_PROFESSIONAL" => Some(Self::Professional),
            "SUBSCRIPTION_TIER_ENTERPRISE" => Some(Self::Enterprise),
            "SUBSCRIPTION_TIER_CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
// =============================================================================
// Audit Event Types
// =============================================================================

/// AuditEventType categorizes security-relevant events for audit logging.
/// Each type can be individually enabled/disabled per tenant.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuditEventType {
    /// Default/unspecified event type.
    Unspecified = 0,
    /// Authentication events (login, logout, MFA, etc.).
    Authentication = 1,
    /// Authorization events (permission checks, access denied, etc.).
    Authorization = 2,
    /// Data access events (read operations on sensitive data).
    DataAccess = 3,
    /// Data modification events (create, update, delete).
    DataModification = 4,
    /// Configuration changes (tenant settings, user roles, etc.).
    ConfigurationChange = 5,
    /// Security events (password changes, key rotation, etc.).
    SecurityEvent = 6,
    /// Compliance events (data export, deletion requests, etc.).
    ComplianceEvent = 7,
    /// Administrative actions (user management, tenant configuration).
    Administrative = 8,
}
impl AuditEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AuditEventType::Unspecified => "AUDIT_EVENT_TYPE_UNSPECIFIED",
            AuditEventType::Authentication => "AUDIT_EVENT_TYPE_AUTHENTICATION",
            AuditEventType::Authorization => "AUDIT_EVENT_TYPE_AUTHORIZATION",
            AuditEventType::DataAccess => "AUDIT_EVENT_TYPE_DATA_ACCESS",
            AuditEventType::DataModification => "AUDIT_EVENT_TYPE_DATA_MODIFICATION",
            AuditEventType::ConfigurationChange => "AUDIT_EVENT_TYPE_CONFIGURATION_CHANGE",
            AuditEventType::SecurityEvent => "AUDIT_EVENT_TYPE_SECURITY_EVENT",
            AuditEventType::ComplianceEvent => "AUDIT_EVENT_TYPE_COMPLIANCE_EVENT",
            AuditEventType::Administrative => "AUDIT_EVENT_TYPE_ADMINISTRATIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUDIT_EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "AUDIT_EVENT_TYPE_AUTHENTICATION" => Some(Self::Authentication),
            "AUDIT_EVENT_TYPE_AUTHORIZATION" => Some(Self::Authorization),
            "AUDIT_EVENT_TYPE_DATA_ACCESS" => Some(Self::DataAccess),
            "AUDIT_EVENT_TYPE_DATA_MODIFICATION" => Some(Self::DataModification),
            "AUDIT_EVENT_TYPE_CONFIGURATION_CHANGE" => Some(Self::ConfigurationChange),
            "AUDIT_EVENT_TYPE_SECURITY_EVENT" => Some(Self::SecurityEvent),
            "AUDIT_EVENT_TYPE_COMPLIANCE_EVENT" => Some(Self::ComplianceEvent),
            "AUDIT_EVENT_TYPE_ADMINISTRATIVE" => Some(Self::Administrative),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
